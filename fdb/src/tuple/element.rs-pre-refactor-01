use bytes::Bytes;
use num_bigint::BigInt;
use uuid::Uuid;

use crate::tuple::{Tuple, Versionstamp};

// The specifications for FDB Tuple layer typecodes is here.
// https://github.com/apple/foundationdb/blob/master/design/tuple.md
// Key and values are encoded as tuples.
#[derive(Clone, PartialEq, Debug)]
pub(crate) enum TupleValue {
    NullValue,                                 // 0x00
    ByteString(Bytes),                         // 0x01
    UnicodeString(String),                     // 0x02
    NestedTuple(Tuple),                        // 0x05
    NegativeArbitraryPrecisionInteger(BigInt), // 0x0b
    NegInt8(u64),                              // 0x0c
    NegInt7(u64),                              // 0x0d
    NegInt6(u64),                              // 0x0e
    NegInt5(u64),                              // 0x0f
    NegInt4(u32),                              // 0x10
    NegInt3(u32),                              // 0x11
    NegInt2(u16),                              // 0x12
    NegInt1(u8),                               // 0x13
    IntZero,                                   // 0x14
    PosInt1(u8),                               // 0x15
    PosInt2(u16),                              // 0x16
    PosInt3(u32),                              // 0x17
    PosInt4(u32),                              // 0x18
    PosInt5(u64),                              // 0x19
    PosInt6(u64),                              // 0x1a
    PosInt7(u64),                              // 0x1b
    PosInt8(u64),                              // 0x1c
    PositiveArbitraryPrecisionInteger(BigInt), // 0x1d
    IeeeBinaryFloatingPointFloat(f32),         // 0x20
    IeeeBinaryFloatingPointDouble(f64),        // 0x21
    FalseValue,                                // 0x26
    TrueValue,                                 // 0x27
    Rfc4122Uuid(Uuid),                         // 0x30
    Versionstamp96Bit(Versionstamp),           // 0x33
}

pub(self) mod parsers {
    use super::TupleValue;

    use bytes::{Buf, BufMut, Bytes, BytesMut};
    use nom::error::{Error, ErrorKind};
    use nom::{bytes as nom_bytes, combinator, multi, number, sequence, IResult};
    use num_bigint::{BigInt, Sign};
    use uuid::Uuid;

    use crate::tuple::{Tuple, Versionstamp};

    // TODO: push this into a private module during rearrangement
    fn neg_u8_slice_into_vec(i: &[u8]) -> Vec<u8> {
        let mut res = Vec::new();
        i.into_iter().for_each(|x| {
            res.push(!(*x));
        });
        res
    }

    // TODO: push this into a private module during rearrangement Both
    // Both `byte_string` and `unicode_string` uses the same packing
    // format.
    fn extract_unpacked_bytes(mut i: &[u8]) -> IResult<&[u8], Bytes> {
        let mut res_output = BytesMut::new();
        let res_input;

        loop {
            let (i1, o1) = nom_bytes::complete::take_until(&b"\x00"[..])(i)?;
            res_output.put(o1);

            // At this time i1 is either b"\x00", or b"\x00\xFF", or b"\x00....".
            if i1.len() >= 2 {
                if i1[1] == b'\xFF' {
                    res_output.put(&b"\x00"[..]);
                    // Update i1, so we can iterate through the loop.
                    i = &i1[2..];
                } else {
                    // exit the loop
                    res_input = &i1[1..];
                    return Ok((res_input, res_output.into()));
                }
            } else {
                // When i1.len() == 1, it means that we have b"\x00".
                res_input = &i1[1..];
                return Ok((res_input, res_output.into()));
            }
        }
    }

    fn null_value(i: &[u8]) -> IResult<&[u8], TupleValue> {
        combinator::map(nom_bytes::complete::tag(&b"\x00"[..]), |_| {
            TupleValue::NullValue
        })(i)
    }

    // Null values inside a tuple are represented differently.
    fn tuple_null_value(i: &[u8]) -> IResult<&[u8], TupleValue> {
        combinator::map(nom_bytes::complete::tag(&b"\x00\xFF"[..]), |_| {
            TupleValue::NullValue
        })(i)
    }

    fn byte_string(i: &[u8]) -> IResult<&[u8], TupleValue> {
        let (i1, _) = nom_bytes::complete::tag(&b"\x01"[..])(i)?;

        let (res_input, res_output) = extract_unpacked_bytes(i1)?;

        Ok((res_input, TupleValue::ByteString(res_output.into())))
    }

    fn unicode_string(i: &[u8]) -> IResult<&[u8], TupleValue> {
        let (i1, _) = nom_bytes::complete::tag(&b"\x02"[..])(i)?;

        let (res_input, res_bytes) = extract_unpacked_bytes(i1)?;

        let res_string = String::from_utf8((&res_bytes[..]).to_vec())
            .map_err(|_| nom::Err::Error(Error::new(res_input, ErrorKind::Fail)))?;

        Ok((res_input, TupleValue::UnicodeString(res_string)))
    }

    fn nested_tuple(i: &[u8]) -> IResult<&[u8], TupleValue> {
        #[derive(Debug)]
        enum NestedTuple<'a> {
            Value((&'a [u8], TupleValue)),
            End(&'a [u8]),
            NoParserFound(&'a [u8]),
        }

        let mut res: Vec<TupleValue> = Vec::new();
        let (mut i1, _) = nom_bytes::complete::tag(&b"\x05"[..])(i)?;

        loop {
            match i1.len() {
                0 => {
                    // We have a premature ending. Return an error.
                    return Err(nom::Err::Error(nom::error::Error::new(
                        i1,
                        nom::error::ErrorKind::Eof,
                    )));
                }
                1 if i1[0] == b'\x00' => {
                    return Ok((
                        // Consume the last remaining '\x00', and return the existing vec.
                        &i1[1..],
                        TupleValue::NestedTuple(Tuple::from_elements(res)),
                    ));
                }
                _ => {
                    let val = if &i1[0..=1] == &b"\x00\xFF"[..] {
                        tuple_null_value(i1).map(NestedTuple::Value)
                    } else {
                        match i1[0] {
                            b'\x00' => Ok(NestedTuple::End(&i1[1..])),
                            b'\x01' => byte_string(i1).map(NestedTuple::Value),
                            b'\x02' => unicode_string(i1).map(NestedTuple::Value),
                            b'\x05' => nested_tuple(i1).map(NestedTuple::Value),
                            b'\x0B' => {
                                negative_arbitrary_precision_integer(i1).map(NestedTuple::Value)
                            }
                            b'\x0C' => neg_int_8(i1).map(NestedTuple::Value),
                            b'\x0D' => neg_int_7(i1).map(NestedTuple::Value),
                            b'\x0E' => neg_int_6(i1).map(NestedTuple::Value),
                            b'\x0F' => neg_int_5(i1).map(NestedTuple::Value),
                            b'\x10' => neg_int_4(i1).map(NestedTuple::Value),
                            b'\x11' => neg_int_3(i1).map(NestedTuple::Value),
                            b'\x12' => neg_int_2(i1).map(NestedTuple::Value),
                            b'\x13' => neg_int_1(i1).map(NestedTuple::Value),
                            b'\x14' => int_zero(i1).map(NestedTuple::Value),
                            b'\x15' => pos_int_1(i1).map(NestedTuple::Value),
                            b'\x16' => pos_int_2(i1).map(NestedTuple::Value),
                            b'\x17' => pos_int_3(i1).map(NestedTuple::Value),
                            b'\x18' => pos_int_4(i1).map(NestedTuple::Value),
                            b'\x19' => pos_int_5(i1).map(NestedTuple::Value),
                            b'\x1A' => pos_int_6(i1).map(NestedTuple::Value),
                            b'\x1B' => pos_int_7(i1).map(NestedTuple::Value),
                            b'\x1C' => pos_int_8(i1).map(NestedTuple::Value),
                            b'\x1D' => {
                                positive_arbitrary_precision_integer(i1).map(NestedTuple::Value)
                            }

                            b'\x20' => ieee_binary_floating_point_float(i1).map(NestedTuple::Value),
                            b'\x21' => {
                                ieee_binary_floating_point_double(i1).map(NestedTuple::Value)
                            }
                            b'\x26' => false_value(i1).map(NestedTuple::Value),
                            b'\x27' => true_value(i1).map(NestedTuple::Value),
                            b'\x30' => rfc_1422_uuid(i1).map(NestedTuple::Value),
                            b'\x33' => versionstamp_96_bit(i1).map(NestedTuple::Value),
                            _ => Ok(NestedTuple::NoParserFound(i1)),
                        }
                    }?;

                    match val {
                        NestedTuple::Value((i2, tv)) => {
                            // continue looping
                            res.push(tv);
                            i1 = i2;
                        }
                        NestedTuple::End(i2) => {
                            return Ok((i2, TupleValue::NestedTuple(Tuple::from_elements(res))));
                        }
                        NestedTuple::NoParserFound(i2) => {
                            return Err(nom::Err::Error(nom::error::Error::new(
                                i2,
                                nom::error::ErrorKind::Fail,
                            )));
                        }
                    }
                }
            }
        }
    }

    fn negative_arbitrary_precision_integer(i: &[u8]) -> IResult<&[u8], TupleValue> {
        let (i1, _) = nom_bytes::complete::tag(&b"\x0B"[..])(i)?;
        let (i2, o2) = nom_bytes::complete::take(1u8)(i1)?;
        let len = o2[0] ^ 0xFFu8;

        // NOTE: Within
        // `TupleValue::NegativeArbitraryPrecisionInteger`, we
        // maintain the negative `BigInt` in the positive (unsigned)
        // form.
        combinator::map(nom_bytes::complete::take(len), |x: &[u8]| {
            TupleValue::NegativeArbitraryPrecisionInteger(BigInt::from_bytes_be(
                Sign::Plus,
                &neg_u8_slice_into_vec(x)[..],
            ))
        })(i2)
    }

    fn neg_int_8(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x0C"[..]),
            combinator::map(nom_bytes::complete::take(8u8), |x: &[u8]| {
                TupleValue::NegInt8((&neg_u8_slice_into_vec(x)[..]).get_u64())
            }),
        )(i)
    }

    fn neg_int_7(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x0D"[..]),
            combinator::map(nom_bytes::complete::take(7u8), |x: &[u8]| {
                let mut val = vec![0xFFu8];
                val.extend_from_slice(x);
                TupleValue::NegInt7((&neg_u8_slice_into_vec(&val[..])[..]).get_u64())
            }),
        )(i)
    }

    fn neg_int_6(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x0E"[..]),
            combinator::map(nom_bytes::complete::take(6u8), |x: &[u8]| {
                let mut val = vec![0xFFu8, 0xFFu8];
                val.extend_from_slice(x);
                TupleValue::NegInt6((&neg_u8_slice_into_vec(&val[..])[..]).get_u64())
            }),
        )(i)
    }

    fn neg_int_5(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x0F"[..]),
            combinator::map(nom_bytes::complete::take(5u8), |x: &[u8]| {
                let mut val = vec![0xFFu8, 0xFFu8, 0xFFu8];
                val.extend_from_slice(x);
                TupleValue::NegInt5((&neg_u8_slice_into_vec(&val[..])[..]).get_u64())
            }),
        )(i)
    }

    fn neg_int_4(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x10"[..]),
            combinator::map(nom_bytes::complete::take(4u8), |x: &[u8]| {
                TupleValue::NegInt4((&neg_u8_slice_into_vec(x)[..]).get_u32())
            }),
        )(i)
    }

    fn neg_int_3(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x11"[..]),
            combinator::map(nom_bytes::complete::take(3u8), |x: &[u8]| {
                let mut val = vec![0xFFu8];
                val.extend_from_slice(x);
                TupleValue::NegInt3((&neg_u8_slice_into_vec(&val[..])[..]).get_u32())
            }),
        )(i)
    }

    fn neg_int_2(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x12"[..]),
            combinator::map(nom_bytes::complete::take(2u8), |x: &[u8]| {
                TupleValue::NegInt2((&neg_u8_slice_into_vec(x)[..]).get_u16())
            }),
        )(i)
    }

    fn neg_int_1(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x13"[..]),
            combinator::map(nom_bytes::complete::take(1u8), |x: &[u8]| {
                TupleValue::NegInt1((&neg_u8_slice_into_vec(x)[..]).get_u8())
            }),
        )(i)
    }

    fn int_zero(i: &[u8]) -> IResult<&[u8], TupleValue> {
        combinator::map(nom_bytes::complete::tag(&b"\x14"[..]), |_| {
            TupleValue::IntZero
        })(i)
    }

    fn pos_int_1(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x15"[..]),
            combinator::map(nom_bytes::complete::take(1u8), |mut x: &[u8]| {
                TupleValue::PosInt1(x.get_u8())
            }),
        )(i)
    }

    fn pos_int_2(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x16"[..]),
            combinator::map(nom_bytes::complete::take(2u8), |mut x: &[u8]| {
                TupleValue::PosInt2(x.get_u16())
            }),
        )(i)
    }

    fn pos_int_3(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x17"[..]),
            combinator::map(nom_bytes::complete::take(3u8), |x: &[u8]| {
                let mut val = vec![0u8];
                val.extend_from_slice(x);
                TupleValue::PosInt3((&val[..]).get_u32().into())
            }),
        )(i)
    }

    fn pos_int_4(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x18"[..]),
            combinator::map(nom_bytes::complete::take(4u8), |mut x: &[u8]| {
                TupleValue::PosInt4(x.get_u32())
            }),
        )(i)
    }

    fn pos_int_5(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x19"[..]),
            combinator::map(nom_bytes::complete::take(5u8), |x: &[u8]| {
                let mut val = vec![0u8, 0u8, 0u8];
                val.extend_from_slice(x);
                TupleValue::PosInt5((&val[..]).get_u64().into())
            }),
        )(i)
    }

    fn pos_int_6(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x1A"[..]),
            combinator::map(nom_bytes::complete::take(6u8), |x: &[u8]| {
                let mut val = vec![0u8, 0u8];
                val.extend_from_slice(x);
                TupleValue::PosInt6((&val[..]).get_u64().into())
            }),
        )(i)
    }

    fn pos_int_7(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x1B"[..]),
            combinator::map(nom_bytes::complete::take(7u8), |x: &[u8]| {
                let mut val = vec![0u8];
                val.extend_from_slice(x);
                TupleValue::PosInt7((&val[..]).get_u64().into())
            }),
        )(i)
    }

    fn pos_int_8(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x1C"[..]),
            combinator::map(nom_bytes::complete::take(8u8), |mut x: &[u8]| {
                TupleValue::PosInt8(x.get_u64())
            }),
        )(i)
    }

    fn positive_arbitrary_precision_integer(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x1D"[..]),
            combinator::map(multi::length_data(number::complete::be_u8), |x| {
                TupleValue::PositiveArbitraryPrecisionInteger(BigInt::from_bytes_be(Sign::Plus, x))
            }),
        )(i)
    }

    fn ieee_binary_floating_point_float(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x20"[..]),
            combinator::map(nom_bytes::complete::take(4u8), |x: &[u8]| {
                if x[0] & 0x80 == 0x00 {
                    // Negative number. Flip all the bytes.
                    let mut res = Vec::new();
                    x.into_iter().for_each(|y| res.push(*y ^ 0xFF));
                    TupleValue::IeeeBinaryFloatingPointFloat((&res[..]).get_f32())
                } else {
                    // Positive number. Flip just the sign bit.
                    let mut res = Vec::new();
                    res.push(x[0] ^ 0x80);
                    x[1..].into_iter().for_each(|y| res.push(*y));
                    TupleValue::IeeeBinaryFloatingPointFloat((&res[..]).get_f32())
                }
            }),
        )(i)
    }

    fn ieee_binary_floating_point_double(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x21"[..]),
            combinator::map(nom_bytes::complete::take(8u8), |x: &[u8]| {
                if x[0] & 0x80 == 0x00 {
                    // Negative number. Flip all the bytes.
                    let mut res = Vec::new();
                    x.into_iter().for_each(|y| res.push(*y ^ 0xFF));
                    TupleValue::IeeeBinaryFloatingPointDouble((&res[..]).get_f64())
                } else {
                    // Positive number. Flip just the sign bit.
                    let mut res = Vec::new();
                    res.push(x[0] ^ 0x80);
                    x[1..].into_iter().for_each(|y| res.push(*y));
                    TupleValue::IeeeBinaryFloatingPointDouble((&res[..]).get_f64())
                }
            }),
        )(i)
    }

    fn false_value(i: &[u8]) -> IResult<&[u8], TupleValue> {
        combinator::map(nom_bytes::complete::tag(&b"\x26"[..]), |_| {
            TupleValue::FalseValue
        })(i)
    }

    fn true_value(i: &[u8]) -> IResult<&[u8], TupleValue> {
        combinator::map(nom_bytes::complete::tag(&b"\x27"[..]), |_| {
            TupleValue::TrueValue
        })(i)
    }

    fn rfc_1422_uuid(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x30"[..]),
            combinator::map(nom_bytes::complete::take(16u8), |x: &[u8]| {
                // It is safe to unwrap, because we are taking 16 bytes.
                TupleValue::Rfc4122Uuid(Uuid::from_slice(x).unwrap())
            }),
        )(i)
    }

    fn versionstamp_96_bit(i: &[u8]) -> IResult<&[u8], TupleValue> {
        sequence::preceded(
            nom_bytes::complete::tag(&b"\x33"[..]),
            combinator::map(nom_bytes::complete::take(12u8), |x: &[u8]| {
                // `from_bytes` won't panic because we are taking 12 bytes.
                TupleValue::Versionstamp96Bit(Versionstamp::from_bytes(Bytes::from(x.to_vec())))
            }),
        )(i)
    }

    pub(self) mod tuple_extractor {
        use super::TupleValue;
        use crate::error::{FdbError, FdbResult, TUPLE_EXTRACTOR};
        use crate::tuple::{Tuple, Versionstamp};
        use bytes::Bytes;
        use num_bigint::BigInt;
        use std::convert::TryInto;
        use uuid::Uuid;

        fn tuple_extractor_error() -> FdbError {
            FdbError::new(TUPLE_EXTRACTOR)
        }

        pub(crate) fn null_value(tv: TupleValue) -> FdbResult<()> {
            if let TupleValue::NullValue = tv {
                Ok(())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn tuple_null_value(tv: TupleValue) -> FdbResult<()> {
            if let TupleValue::NullValue = tv {
                Ok(())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn byte_string(tv: TupleValue) -> FdbResult<Bytes> {
            if let TupleValue::ByteString(i) = tv {
                Ok(i)
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn unicode_string(tv: TupleValue) -> FdbResult<String> {
            if let TupleValue::UnicodeString(i) = tv {
                Ok(i)
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn nested_tuple(tv: TupleValue) -> FdbResult<Tuple> {
            if let TupleValue::NestedTuple(i) = tv {
                Ok(i)
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn negative_arbitrary_precision_integer(tv: TupleValue) -> FdbResult<BigInt> {
            if let TupleValue::NegativeArbitraryPrecisionInteger(i) = tv {
                Ok(i * -1)
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn neg_int_8_bigint(tv: TupleValue) -> FdbResult<BigInt> {
            if let TupleValue::NegInt8(i) = tv {
                Ok(Into::<BigInt>::into(i) * -1)
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn neg_int_8_i64(tv: TupleValue) -> FdbResult<i64> {
            if let TupleValue::NegInt8(i) = tv {
                (Into::<i128>::into(i) * -1)
                    .try_into()
                    .map_err(|_| tuple_extractor_error())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn neg_int_7_i64(tv: TupleValue) -> FdbResult<i64> {
            if let TupleValue::NegInt7(i) = tv {
                // Even though NegInt5's range
                // -72057594037927935..=-281474976710656 is well
                // within i64::MIN (-9223372036854775808), this
                // information is not known to `i: u64`. So we need to
                // use `try_into()`.
                i.try_into()
                    .map(|x: i64| x * -1)
                    .map_err(|_| tuple_extractor_error())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn neg_int_6_i64(tv: TupleValue) -> FdbResult<i64> {
            if let TupleValue::NegInt6(i) = tv {
                // Even though NegInt5's range
                // -281474976710655..=-1099511627776 is well within
                // i64::MIN (-9223372036854775808), this information
                // is not known to `i: u64`. So we need to use
                // `try_into()`.
                i.try_into()
                    .map(|x: i64| x * -1)
                    .map_err(|_| tuple_extractor_error())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn neg_int_5_i64(tv: TupleValue) -> FdbResult<i64> {
            if let TupleValue::NegInt5(i) = tv {
                // Even though NegInt5's range
                // -1099511627775..=-4294967296 is well within
                // i64::MIN (-9223372036854775808), this information
                // is not known to `i: u64`. So we need to use
                // `try_into()`.
                i.try_into()
                    .map(|x: i64| x * -1)
                    .map_err(|_| tuple_extractor_error())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn neg_int_4_i64(tv: TupleValue) -> FdbResult<i64> {
            if let TupleValue::NegInt4(i) = tv {
                Ok(Into::<i64>::into(i) * -1)
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn neg_int_4_i32(tv: TupleValue) -> FdbResult<i32> {
            if let TupleValue::NegInt4(i) = tv {
                (Into::<i64>::into(i) * -1)
                    .try_into()
                    .map_err(|_| tuple_extractor_error())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn neg_int_3_i32(tv: TupleValue) -> FdbResult<i32> {
            if let TupleValue::NegInt3(i) = tv {
                // Even though NegInt3's range -16777215..=-65536 is
                // well within i32::MIN (-2147483648), this
                // information is not known to `i: u32`. So, we need
                // to use `try_into()`.
                i.try_into()
                    .map(|x: i32| x * -1)
                    .map_err(|_| tuple_extractor_error())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn neg_int_2_i32(tv: TupleValue) -> FdbResult<i32> {
            if let TupleValue::NegInt2(i) = tv {
                Ok(Into::<i32>::into(i) * -1)
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn neg_int_2_i16(tv: TupleValue) -> FdbResult<i16> {
            if let TupleValue::NegInt2(i) = tv {
                (Into::<i32>::into(i) * -1)
                    .try_into()
                    .map_err(|_| tuple_extractor_error())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn neg_int_1_i16(tv: TupleValue) -> FdbResult<i16> {
            if let TupleValue::NegInt1(i) = tv {
                Ok(Into::<i16>::into(i) * -1)
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn neg_int_1_i8(tv: TupleValue) -> FdbResult<i8> {
            if let TupleValue::NegInt1(i) = tv {
                (Into::<i16>::into(i) * -1)
                    .try_into()
                    .map_err(|_| tuple_extractor_error())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn int_zero(tv: TupleValue) -> FdbResult<i8> {
            if let TupleValue::IntZero = tv {
                Ok(0)
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn pos_int_1_i8(tv: TupleValue) -> FdbResult<i8> {
            if let TupleValue::PosInt1(i) = tv {
                i.try_into().map_err(|_| tuple_extractor_error())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn pos_int_1_i16(tv: TupleValue) -> FdbResult<i16> {
            if let TupleValue::PosInt1(i) = tv {
                Ok(i.into())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn pos_int_2_i16(tv: TupleValue) -> FdbResult<i16> {
            if let TupleValue::PosInt2(i) = tv {
                i.try_into().map_err(|_| tuple_extractor_error())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn pos_int_2_i32(tv: TupleValue) -> FdbResult<i32> {
            if let TupleValue::PosInt2(i) = tv {
                Ok(i.into())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn pos_int_3_i32(tv: TupleValue) -> FdbResult<i32> {
            if let TupleValue::PosInt3(i) = tv {
                // Even though PosInt3's range 65536..=16777215 is
                // within i32::MAX (2147483647), this information is
                // not known to `i: u32`. So we need to use
                // `try_into()`.
                i.try_into().map_err(|_| tuple_extractor_error())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn pos_int_4_i32(tv: TupleValue) -> FdbResult<i32> {
            if let TupleValue::PosInt4(i) = tv {
                i.try_into().map_err(|_| tuple_extractor_error())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn pos_int_4_i64(tv: TupleValue) -> FdbResult<i64> {
            if let TupleValue::PosInt4(i) = tv {
                Ok(i.into())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn pos_int_5_i64(tv: TupleValue) -> FdbResult<i64> {
            if let TupleValue::PosInt5(i) = tv {
                // Even though PosInt5's range
                // 4294967296..=1099511627775 is within i64::MAX
                // (9223372036854775807), this information is not
                // known to `i: u64`. So we need to use `try_into()`.
                i.try_into().map_err(|_| tuple_extractor_error())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn pos_int_6_i64(tv: TupleValue) -> FdbResult<i64> {
            if let TupleValue::PosInt6(i) = tv {
                // Even though PosInt6's range
                // 1099511627776..=281474976710655 is within i64::MAX
                // (9223372036854775807), this information is not
                // known to `i: u64`. So we need to use `try_into()`.
                i.try_into().map_err(|_| tuple_extractor_error())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn pos_int_7_i64(tv: TupleValue) -> FdbResult<i64> {
            if let TupleValue::PosInt7(i) = tv {
                // Even though PosInt6's range
                // 281474976710656..=72057594037927935 is within
                // i64::MAX (9223372036854775807), this information is
                // not known to `i: u64`. So we need to use
                // `try_into()`.
                i.try_into().map_err(|_| tuple_extractor_error())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn pos_int_8_i64(tv: TupleValue) -> FdbResult<i64> {
            if let TupleValue::PosInt8(i) = tv {
                i.try_into().map_err(|_| tuple_extractor_error())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn pos_int_8_bigint(tv: TupleValue) -> FdbResult<BigInt> {
            if let TupleValue::PosInt8(i) = tv {
                Ok(i.into())
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn positive_arbitrary_precision_integer(tv: TupleValue) -> FdbResult<BigInt> {
            if let TupleValue::PositiveArbitraryPrecisionInteger(i) = tv {
                Ok(i)
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn ieee_binary_floating_point_float(tv: TupleValue) -> FdbResult<f32> {
            if let TupleValue::IeeeBinaryFloatingPointFloat(i) = tv {
                Ok(i)
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn ieee_binary_floating_point_double(tv: TupleValue) -> FdbResult<f64> {
            if let TupleValue::IeeeBinaryFloatingPointDouble(i) = tv {
                Ok(i)
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn false_value(tv: TupleValue) -> FdbResult<bool> {
            if let TupleValue::FalseValue = tv {
                Ok(false)
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn true_value(tv: TupleValue) -> FdbResult<bool> {
            if let TupleValue::TrueValue = tv {
                Ok(true)
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn rfc_1422_uuid(tv: TupleValue) -> FdbResult<Uuid> {
            if let TupleValue::Rfc4122Uuid(i) = tv {
                Ok(i)
            } else {
                Err(tuple_extractor_error())
            }
        }

        pub(crate) fn versionstamp_96_bit(tv: TupleValue) -> FdbResult<Versionstamp> {
            if let TupleValue::Versionstamp96Bit(i) = tv {
                Ok(i)
            } else {
                Err(tuple_extractor_error())
            }
        }
    }

    #[cfg(test)]
    mod tests {
        use super::{
            byte_string, false_value, ieee_binary_floating_point_double,
            ieee_binary_floating_point_float, int_zero, neg_int_1, neg_int_2, neg_int_3, neg_int_4,
            neg_int_5, neg_int_6, neg_int_7, neg_int_8, negative_arbitrary_precision_integer,
            nested_tuple, null_value, pos_int_1, pos_int_2, pos_int_3, pos_int_4, pos_int_5,
            pos_int_6, pos_int_7, pos_int_8, positive_arbitrary_precision_integer, rfc_1422_uuid,
            true_value, tuple_extractor, tuple_null_value, unicode_string, versionstamp_96_bit,
            TupleValue,
        };
        use crate::tuple::{Tuple, Versionstamp};
        use bytes::Bytes;
        use nom::error::{Error, ErrorKind};
        use num_bigint::BigInt;
        use std::num::NonZeroUsize;
        use uuid::Uuid;

        #[test]
        fn test_null_value() {
            assert_eq!(
                null_value(&b"\x00moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::NullValue))
            );
            assert_eq!(
                null_value(&b"no_null_value"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_null_value"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::null_value(null_value(&b"\x00moredata"[..]).unwrap().1).unwrap(),
                ()
            );
        }

        #[test]
        fn test_tuple_null_value() {
            assert_eq!(
                tuple_null_value(&b"\x00\xFFmoredata"[..]),
                Ok((&b"moredata"[..], TupleValue::NullValue))
            );
            assert_eq!(
                null_value(&b"no_tuple_null_value"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_tuple_null_value"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::tuple_null_value(null_value(&b"\x00\xFFmoredata"[..]).unwrap().1)
                    .unwrap(),
                ()
            );
        }

        #[test]
        fn test_byte_string() {
            assert_eq!(
                byte_string(&b"\x01\x00"[..]),
                Ok((
                    &b""[..],
                    TupleValue::ByteString(Bytes::from_static(&b""[..]))
                ))
            );
            assert_eq!(
                byte_string(&b"\x01\x00moredata"[..]),
                Ok((
                    &b"moredata"[..],
                    TupleValue::ByteString(Bytes::from_static(&b""[..]))
                ))
            );
            assert_eq!(
                byte_string(&b"\x01\x01\x02\x03\x00"[..]),
                Ok((
                    &b""[..],
                    TupleValue::ByteString(Bytes::from_static(&b"\x01\x02\x03"[..]))
                ))
            );
            assert_eq!(
                byte_string(&b"\x01\x01\x02\x03\x00moredata"[..]),
                Ok((
                    &b"moredata"[..],
                    TupleValue::ByteString(Bytes::from_static(&b"\x01\x02\x03"[..]))
                ))
            );
            assert_eq!(
                byte_string(&b"\x01\x00\xFF\x00\xFF\x00\xFF\x04\x00"[..]),
                Ok((
                    &b""[..],
                    TupleValue::ByteString(Bytes::from_static(&b"\x00\x00\x00\x04"[..]))
                ))
            );
            assert_eq!(
                byte_string(&b"\x01\x00\xFF\x00\xFF\x00\xFF\x04\x00moredata"[..]),
                Ok((
                    &b"moredata"[..],
                    TupleValue::ByteString(Bytes::from_static(&b"\x00\x00\x00\x04"[..]))
                ))
            );
            assert_eq!(
                byte_string(&b"no_byte_string"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_byte_string"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::byte_string(
                    byte_string(&b"\x01\x01\x02\x03\x00moredata"[..]).unwrap().1
                )
                .unwrap(),
                Bytes::from_static(&b"\x01\x02\x03"[..])
            );
        }

        #[test]
        fn test_unicode_string() {
            assert_eq!(
                unicode_string(&b"\x02\x00"[..]),
                Ok((&b""[..], TupleValue::UnicodeString("".to_string())))
            );
            assert_eq!(
                unicode_string(&b"\x02\x00moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::UnicodeString("".to_string())))
            );
            assert_eq!(
                unicode_string(&b"\x02hello\x00"[..]),
                Ok((&b""[..], TupleValue::UnicodeString("hello".to_string())))
            );
            assert_eq!(
                unicode_string(&b"\x02hello\x00moredata"[..]),
                Ok((
                    &b"moredata"[..],
                    TupleValue::UnicodeString("hello".to_string())
                ))
            );
            assert_eq!(
                unicode_string(&b"\x02\xE4\xB8\xAD\xE6\x96\x87\x00"[..]),
                Ok((&b""[..], TupleValue::UnicodeString("中文".to_string())))
            );
            assert_eq!(
                unicode_string(&b"\x02\xE4\xB8\xAD\xE6\x96\x87\x00moredata"[..]),
                Ok((
                    &b"moredata"[..],
                    TupleValue::UnicodeString("中文".to_string())
                ))
            );
            assert_eq!(
                unicode_string(&b"\x02\xCE\xBC\xCE\xAC\xCE\xB8\xCE\xB7\xCE\xBC\xCE\xB1\x00"[..]),
                Ok((&b""[..], TupleValue::UnicodeString("μάθημα".to_string())))
            );
            assert_eq!(
                unicode_string(
                    &b"\x02\xCE\xBC\xCE\xAC\xCE\xB8\xCE\xB7\xCE\xBC\xCE\xB1\x00moredata"[..]
                ),
                Ok((
                    &b"moredata"[..],
                    TupleValue::UnicodeString("μάθημα".to_string())
                ))
            );
            assert_eq!(
                byte_string(&b"no_unicode_string"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_unicode_string"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::unicode_string(
                    unicode_string(&b"\x02hello\x00moredata"[..]).unwrap().1
                )
                .unwrap(),
                "hello".to_string()
            );
        }

        #[test]
        fn test_nested_tuple() {
            assert_eq!(
                nested_tuple(&b"\x05\x00\xFF\x00"[..]),
                Ok((
                    &b""[..],
                    TupleValue::NestedTuple(Tuple::from_elements(vec![TupleValue::NullValue]))
                ))
            );
            assert_eq!(
                nested_tuple(&b"\x05\x00\xFF\x00moredata"[..]),
                Ok((
                    &b"moredata"[..],
                    TupleValue::NestedTuple(Tuple::from_elements(vec![TupleValue::NullValue]))
                ))
            );
            assert_eq!(
                nested_tuple(&b"\x05\x00\xFF\x02hello\x00\x00"[..]),
                Ok((
                    &b""[..],
                    TupleValue::NestedTuple(Tuple::from_elements(vec![
                        TupleValue::NullValue,
                        TupleValue::UnicodeString("hello".to_string()),
                    ]))
                ))
            );
            assert_eq!(
                nested_tuple(&b"\x05\x00\xFF\x02hello\x00\x00moredata"[..]),
                Ok((
                    &b"moredata"[..],
                    TupleValue::NestedTuple(Tuple::from_elements(vec![
                        TupleValue::NullValue,
                        TupleValue::UnicodeString("hello".to_string()),
                    ]))
                ))
            );
            assert_eq!(
                nested_tuple(&b"\x05\x00\xFF\x02hell\x00\xFF\x00\x00"[..]),
                Ok((
                    &b""[..],
                    TupleValue::NestedTuple(Tuple::from_elements(vec![
                        TupleValue::NullValue,
                        TupleValue::UnicodeString("hell\u{0}".to_string()),
                    ]))
                ))
            );
            assert_eq!(
                nested_tuple(&b"\x05\x00\xFF\x02hell\x00\xFF\x00\x00moredata"[..]),
                Ok((
                    &b"moredata"[..],
                    TupleValue::NestedTuple(Tuple::from_elements(vec![
                        TupleValue::NullValue,
                        TupleValue::UnicodeString("hell\u{0}".to_string()),
                    ]))
                ))
            );
            assert_eq!(
                nested_tuple(&b"\x05\x00\xFF\x34hello\x00\x00"[..]),
                Err(nom::Err::Error(nom::error::Error::new(
                    &b"\x34hello\x00\x00"[..],
                    nom::error::ErrorKind::Fail
                )))
            );
            assert_eq!(
                nested_tuple(&b"\x05"[..]),
                Err(nom::Err::Error(nom::error::Error::new(
                    &b""[..],
                    nom::error::ErrorKind::Eof
                )))
            );
            assert_eq!(
                nested_tuple(&b"no_nested_tuple"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_nested_tuple"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::nested_tuple(
                    nested_tuple(&b"\x05\x00\xFF\x02hell\x00\xFF\x00\x00moredata"[..])
                        .unwrap()
                        .1
                )
                .unwrap(),
                Tuple::from_elements(vec![
                    TupleValue::NullValue,
                    TupleValue::UnicodeString("hell\u{0}".to_string())
                ])
            );
        }

        #[test]
        fn test_negative_arbitrary_precision_integer() {
            assert_eq!(
                negative_arbitrary_precision_integer(
                    &b"\x0B\xF6\xFE\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFmoredata"[..]
                ),
                Ok((
                    &b"moredata"[..],
                    TupleValue::NegativeArbitraryPrecisionInteger(
                        BigInt::parse_bytes(b"18446744073709551616", 10).unwrap()
                    )
                ))
            );
            assert_eq!(
                positive_arbitrary_precision_integer(
                    &b"no_negative_arbitrary_precision_integer"[..]
                ),
                Err(nom::Err::Error(Error::new(
                    &b"no_negative_arbitrary_precision_integer"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                negative_arbitrary_precision_integer(
                    &b"\x0B\xF6\xFE\xFF\xFF\xFF\xFF\xFF\xFF\xFF"[..]
                ),
                Err(nom::Err::Error(nom::error::Error::new(
                    &b"\xFE\xFF\xFF\xFF\xFF\xFF\xFF\xFF"[..],
                    nom::error::ErrorKind::Eof
                )))
            );
            assert_eq!(
                tuple_extractor::negative_arbitrary_precision_integer(
                    negative_arbitrary_precision_integer(
                        &b"\x0B\xF6\xFE\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFmoredata"[..]
                    )
                    .unwrap()
                    .1
                )
                .unwrap(),
                BigInt::parse_bytes(b"-18446744073709551616", 10).unwrap()
            );
        }

        #[test]
        fn test_neg_int_8() {
            assert_eq!(
                neg_int_8(&b"\x0C\x00\x00\x00\x00\x00\x00\x00\x00moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::NegInt8(18446744073709551615)))
            );
            assert_eq!(
                neg_int_8(&b"\x0C\xFE\xFF\xFF\xFF\xFF\xFF\xFF\xFFmoredata"[..]),
                Ok((&b"moredata"[..], TupleValue::NegInt8(72057594037927936)))
            );
            assert_eq!(
                neg_int_8(&b"no_neg_int_8"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_neg_int_8"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::neg_int_8_bigint(
                    neg_int_8(&b"\x0C\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFEmoredata"[..])
                        .unwrap()
                        .1
                )
                .unwrap(),
                BigInt::parse_bytes(b"-9223372036854775809", 10).unwrap()
            );
            assert_eq!(
                tuple_extractor::neg_int_8_i64(
                    neg_int_8(&b"\x0C\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFFmoredata"[..])
                        .unwrap()
                        .1
                )
                .unwrap(),
                -9223372036854775808i64
            );
        }

        #[test]
        fn test_neg_int_7() {
            assert_eq!(
                neg_int_7(&b"\x0D\x00\x00\x00\x00\x00\x00\x00moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::NegInt7(72057594037927935)))
            );
            assert_eq!(
                neg_int_7(&b"\x0D\xFE\xFF\xFF\xFF\xFF\xFF\xFFmoredata"[..]),
                Ok((&b"moredata"[..], TupleValue::NegInt7(281474976710656)))
            );
            assert_eq!(
                neg_int_7(&b"no_neg_int_7"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_neg_int_7"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::neg_int_7_i64(
                    neg_int_7(&b"\x0D\x00\x00\x00\x00\x00\x00\x00moredata"[..])
                        .unwrap()
                        .1
                )
                .unwrap(),
                -72057594037927935i64
            );
            assert_eq!(
                tuple_extractor::neg_int_7_i64(
                    neg_int_7(&b"\x0D\xFE\xFF\xFF\xFF\xFF\xFF\xFFmoredata"[..])
                        .unwrap()
                        .1
                )
                .unwrap(),
                -281474976710656i64
            );
        }

        #[test]
        fn test_neg_int_6() {
            assert_eq!(
                neg_int_6(&b"\x0E\x00\x00\x00\x00\x00\x00moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::NegInt6(281474976710655)))
            );
            assert_eq!(
                neg_int_6(&b"\x0E\xFE\xFF\xFF\xFF\xFF\xFFmoredata"[..]),
                Ok((&b"moredata"[..], TupleValue::NegInt6(1099511627776)))
            );
            assert_eq!(
                neg_int_6(&b"no_neg_int_6"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_neg_int_6"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::neg_int_6_i64(
                    neg_int_6(&b"\x0E\x00\x00\x00\x00\x00\x00moredata"[..])
                        .unwrap()
                        .1
                )
                .unwrap(),
                -281474976710655i64
            );
            assert_eq!(
                tuple_extractor::neg_int_6_i64(
                    neg_int_6(&b"\x0E\xFE\xFF\xFF\xFF\xFF\xFFmoredata"[..])
                        .unwrap()
                        .1
                )
                .unwrap(),
                -1099511627776i64
            );
        }

        #[test]
        fn test_neg_int_5() {
            assert_eq!(
                neg_int_5(&b"\x0F\x00\x00\x00\x00\x00moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::NegInt5(1099511627775)))
            );
            assert_eq!(
                neg_int_5(&b"\x0F\xFE\xFF\xFF\xFF\xFFmoredata"[..]),
                Ok((&b"moredata"[..], TupleValue::NegInt5(4294967296)))
            );
            assert_eq!(
                neg_int_5(&b"no_neg_int_5"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_neg_int_5"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::neg_int_5_i64(
                    neg_int_5(&b"\x0F\x00\x00\x00\x00\x00moredata"[..])
                        .unwrap()
                        .1
                )
                .unwrap(),
                -1099511627775i64
            );
            assert_eq!(
                tuple_extractor::neg_int_5_i64(
                    neg_int_5(&b"\x0F\xFE\xFF\xFF\xFF\xFFmoredata"[..])
                        .unwrap()
                        .1
                )
                .unwrap(),
                -4294967296i64
            );
        }

        #[test]
        fn test_neg_int_4() {
            assert_eq!(
                neg_int_4(&b"\x10\x00\x00\x00\x00moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::NegInt4(4294967295)))
            );
            assert_eq!(
                neg_int_4(&b"\x10\xFE\xFF\xFF\xFFmoredata"[..]),
                Ok((&b"moredata"[..], TupleValue::NegInt4(16777216)))
            );
            assert_eq!(
                neg_int_4(&b"no_neg_int_4"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_neg_int_4"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::neg_int_4_i64(
                    neg_int_4(&b"\x10\x7F\xFF\xFF\xFEmoredata"[..]).unwrap().1
                )
                .unwrap(),
                -2147483649i64
            );
            assert_eq!(
                tuple_extractor::neg_int_4_i32(
                    neg_int_4(&b"\x10\x7F\xFF\xFF\xFFmoredata"[..]).unwrap().1
                )
                .unwrap(),
                -2147483648i32
            );
        }

        #[test]
        fn test_neg_int_3() {
            assert_eq!(
                neg_int_3(&b"\x11\x00\x00\x00moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::NegInt3(16777215)))
            );
            assert_eq!(
                neg_int_3(&b"\x11\xFE\xFF\xFFmoredata"[..]),
                Ok((&b"moredata"[..], TupleValue::NegInt3(65536)))
            );
            assert_eq!(
                neg_int_3(&b"no_neg_int_3"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_neg_int_3"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::neg_int_3_i32(
                    neg_int_3(&b"\x11\x00\x00\x00moredata"[..]).unwrap().1
                )
                .unwrap(),
                -16777215i32
            );
            assert_eq!(
                tuple_extractor::neg_int_3_i32(
                    neg_int_3(&b"\x11\xFE\xFF\xFFmoredata"[..]).unwrap().1
                )
                .unwrap(),
                -65536i32
            );
        }

        #[test]
        fn test_neg_int_2() {
            assert_eq!(
                neg_int_2(&b"\x12\x00\x00moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::NegInt2(65535)))
            );
            assert_eq!(
                neg_int_2(&b"\x12\xFE\xFFmoredata"[..]),
                Ok((&b"moredata"[..], TupleValue::NegInt2(256)))
            );
            assert_eq!(
                neg_int_2(&b"no_neg_int_2"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_neg_int_2"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::neg_int_2_i32(neg_int_2(&b"\x12\x7F\xFEmoredata"[..]).unwrap().1)
                    .unwrap(),
                -32769i32
            );
            assert_eq!(
                tuple_extractor::neg_int_2_i16(neg_int_2(&b"\x12\x7F\xFFmoredata"[..]).unwrap().1)
                    .unwrap(),
                -32768i16
            );
        }

        #[test]
        fn test_neg_int_1() {
            assert_eq!(
                neg_int_1(&b"\x13\x00moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::NegInt1(255)))
            );
            assert_eq!(
                neg_int_1(&b"\x13\xFEmoredata"[..]),
                Ok((&b"moredata"[..], TupleValue::NegInt1(1)))
            );
            assert_eq!(
                neg_int_1(&b"no_neg_int_1"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_neg_int_1"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::neg_int_1_i16(neg_int_1(&b"\x13\x7Emoredata"[..]).unwrap().1)
                    .unwrap(),
                -129i16
            );
            assert_eq!(
                tuple_extractor::neg_int_1_i8(neg_int_1(&b"\x13\x7Fmoredata"[..]).unwrap().1)
                    .unwrap(),
                -128i8
            );
        }

        #[test]
        fn test_int_zero() {
            assert_eq!(
                int_zero(&b"\x14moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::IntZero))
            );
            assert_eq!(
                int_zero(&b"no_int_zero"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_int_zero"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::int_zero(int_zero(&b"\x14moredata"[..]).unwrap().1).unwrap(),
                0
            );
        }

        #[test]
        fn test_pos_int_1() {
            assert_eq!(
                pos_int_1(&b"\x15\x01moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::PosInt1(1)))
            );
            assert_eq!(
                pos_int_1(&b"\x15\xFFmoredata"[..]),
                Ok((&b"moredata"[..], TupleValue::PosInt1(255)))
            );
            assert_eq!(
                pos_int_1(&b"no_pos_int_1"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_pos_int_1"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::pos_int_1_i8(pos_int_1(&b"\x15\x7Fmoredata"[..]).unwrap().1)
                    .unwrap(),
                127i8
            );
            assert_eq!(
                tuple_extractor::pos_int_1_i16(pos_int_1(&b"\x15\x80moredata"[..]).unwrap().1)
                    .unwrap(),
                128i16
            );
        }

        #[test]
        fn test_pos_int_2() {
            assert_eq!(
                pos_int_2(&b"\x16\x01\x00moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::PosInt2(256)))
            );
            assert_eq!(
                pos_int_2(&b"\x16\xFF\xFFmoredata"[..]),
                Ok((&b"moredata"[..], TupleValue::PosInt2(65535)))
            );
            assert_eq!(
                pos_int_2(&b"no_pos_int_2"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_pos_int_2"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::pos_int_2_i16(pos_int_2(&b"\x16\x7F\xFFmoredata"[..]).unwrap().1)
                    .unwrap(),
                32767i16
            );
            assert_eq!(
                tuple_extractor::pos_int_2_i32(pos_int_2(&b"\x16\x80\x00moredata"[..]).unwrap().1)
                    .unwrap(),
                32768i32
            );
        }

        #[test]
        fn test_pos_int_3() {
            assert_eq!(
                pos_int_3(&b"\x17\x01\x00\x00moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::PosInt3(65536)))
            );
            assert_eq!(
                pos_int_3(&b"\x17\xFF\xFF\xFFmoredata"[..]),
                Ok((&b"moredata"[..], TupleValue::PosInt3(16777215)))
            );
            assert_eq!(
                pos_int_3(&b"no_pos_int_3"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_pos_int_3"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::pos_int_3_i32(
                    pos_int_3(&b"\x17\x01\x00\x00moredata"[..]).unwrap().1
                )
                .unwrap(),
                65536i32
            );
            assert_eq!(
                tuple_extractor::pos_int_3_i32(
                    pos_int_3(&b"\x17\xFF\xFF\xFFmoredata"[..]).unwrap().1
                )
                .unwrap(),
                16777215i32,
            );
        }

        #[test]
        fn test_pos_int_4() {
            assert_eq!(
                pos_int_4(&b"\x18\x01\x00\x00\x00moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::PosInt4(16777216)))
            );
            assert_eq!(
                pos_int_4(&b"\x18\xFF\xFF\xFF\xFFmoredata"[..]),
                Ok((&b"moredata"[..], TupleValue::PosInt4(4294967295)))
            );
            assert_eq!(
                pos_int_4(&b"no_pos_int_4"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_pos_int_4"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::pos_int_4_i32(
                    pos_int_4(&b"\x18\x7F\xFF\xFF\xFFmoredata"[..]).unwrap().1
                )
                .unwrap(),
                2147483647i32
            );
            assert_eq!(
                tuple_extractor::pos_int_4_i64(
                    pos_int_4(&b"\x18\x80\x00\x00\x00moredata"[..]).unwrap().1
                )
                .unwrap(),
                2147483648i64
            );
        }

        #[test]
        fn test_pos_int_5() {
            assert_eq!(
                pos_int_5(&b"\x19\x01\x00\x00\x00\x00moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::PosInt5(4294967296)))
            );
            assert_eq!(
                pos_int_5(&b"\x19\xFF\xFF\xFF\xFF\xFFmoredata"[..]),
                Ok((&b"moredata"[..], TupleValue::PosInt5(1099511627775)))
            );
            assert_eq!(
                pos_int_5(&b"no_pos_int_5"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_pos_int_5"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::pos_int_5_i64(
                    pos_int_5(&b"\x19\x01\x00\x00\x00\x00moredata"[..])
                        .unwrap()
                        .1
                )
                .unwrap(),
                4294967296i64
            );
            assert_eq!(
                tuple_extractor::pos_int_5_i64(
                    pos_int_5(&b"\x19\xFF\xFF\xFF\xFF\xFFmoredata"[..])
                        .unwrap()
                        .1
                )
                .unwrap(),
                1099511627775i64
            );
        }

        #[test]
        fn test_pos_int_6() {
            assert_eq!(
                pos_int_6(&b"\x1A\x01\x00\x00\x00\x00\x00moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::PosInt6(1099511627776)))
            );
            assert_eq!(
                pos_int_6(&b"\x1A\xFF\xFF\xFF\xFF\xFF\xFFmoredata"[..]),
                Ok((&b"moredata"[..], TupleValue::PosInt6(281474976710655)))
            );
            assert_eq!(
                pos_int_6(&b"no_pos_int_6"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_pos_int_6"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::pos_int_6_i64(
                    pos_int_6(&b"\x1A\x01\x00\x00\x00\x00\x00moredata"[..])
                        .unwrap()
                        .1
                )
                .unwrap(),
                1099511627776i64
            );
            assert_eq!(
                tuple_extractor::pos_int_6_i64(
                    pos_int_6(&b"\x1A\xFF\xFF\xFF\xFF\xFF\xFFmoredata"[..])
                        .unwrap()
                        .1
                )
                .unwrap(),
                281474976710655i64
            );
        }

        #[test]
        fn test_pos_int_7() {
            assert_eq!(
                pos_int_7(&b"\x1B\x01\x00\x00\x00\x00\x00\x00moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::PosInt7(281474976710656)))
            );
            assert_eq!(
                pos_int_7(&b"\x1B\xFF\xFF\xFF\xFF\xFF\xFF\xFFmoredata"[..]),
                Ok((&b"moredata"[..], TupleValue::PosInt7(72057594037927935)))
            );
            assert_eq!(
                pos_int_7(&b"no_pos_int_7"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_pos_int_7"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::pos_int_7_i64(
                    pos_int_7(&b"\x1B\x01\x00\x00\x00\x00\x00\x00moredata"[..])
                        .unwrap()
                        .1
                )
                .unwrap(),
                281474976710656i64
            );
            assert_eq!(
                tuple_extractor::pos_int_7_i64(
                    pos_int_7(&b"\x1B\xFF\xFF\xFF\xFF\xFF\xFF\xFFmoredata"[..])
                        .unwrap()
                        .1
                )
                .unwrap(),
                72057594037927935i64
            );
        }

        #[test]
        fn test_pos_int_8() {
            assert_eq!(
                pos_int_8(&b"\x1C\x01\x00\x00\x00\x00\x00\x00\x00moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::PosInt8(72057594037927936)))
            );
            assert_eq!(
                pos_int_8(&b"\x1C\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFmoredata"[..]),
                Ok((&b"moredata"[..], TupleValue::PosInt8(18446744073709551615)))
            );
            assert_eq!(
                pos_int_8(&b"no_pos_int_8"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_pos_int_8"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::pos_int_8_i64(
                    pos_int_8(&b"\x1C\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFFmoredata"[..])
                        .unwrap()
                        .1
                )
                .unwrap(),
                9223372036854775807i64
            );
            assert_eq!(
                tuple_extractor::pos_int_8_bigint(
                    pos_int_8(&b"\x1C\x80\x00\x00\x00\x00\x00\x00\x00moredata"[..])
                        .unwrap()
                        .1
                )
                .unwrap(),
                BigInt::parse_bytes(b"9223372036854775808", 10).unwrap()
            );
        }

        #[test]
        fn test_positive_arbitrary_precision_integer() {
            assert_eq!(
                positive_arbitrary_precision_integer(
                    &b"\x1D\x09\x01\x00\x00\x00\x00\x00\x00\x00\x00moredata"[..]
                ),
                Ok((
                    &b"moredata"[..],
                    TupleValue::PositiveArbitraryPrecisionInteger(
                        BigInt::parse_bytes(b"18446744073709551616", 10).unwrap()
                    )
                ))
            );
            assert_eq!(
                positive_arbitrary_precision_integer(
                    &b"no_positive_arbitrary_precision_integer"[..]
                ),
                Err(nom::Err::Error(Error::new(
                    &b"no_positive_arbitrary_precision_integer"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                positive_arbitrary_precision_integer(
                    &b"\x1D\x09\x01\x00\x00\x00\x00\x00\x00\x00"[..]
                ),
                Err(nom::Err::Incomplete(nom::Needed::Size(
                    NonZeroUsize::new(1).unwrap()
                )))
            );
            assert_eq!(
                tuple_extractor::positive_arbitrary_precision_integer(
                    positive_arbitrary_precision_integer(
                        &b"\x1D\x09\x01\x00\x00\x00\x00\x00\x00\x00\x00moredata"[..]
                    )
                    .unwrap()
                    .1
                )
                .unwrap(),
                BigInt::parse_bytes(b"18446744073709551616", 10).unwrap()
            );
        }

        #[test]
        fn test_ieee_binary_floating_point_float() {
            assert_eq!(
                ieee_binary_floating_point_float(&b"\x20\xC0\x48\xF5\xC3moredata"[..]),
                Ok((
                    &b"moredata"[..],
                    TupleValue::IeeeBinaryFloatingPointFloat(3.14f32)
                ))
            );
            assert_eq!(
                ieee_binary_floating_point_float(&b"\x20\x3F\xB7\x0A\x3Cmoredata"[..]),
                Ok((
                    &b"moredata"[..],
                    TupleValue::IeeeBinaryFloatingPointFloat(-3.14f32)
                ))
            );
            assert_eq!(
                ieee_binary_floating_point_float(&b"\x20\x80\x00\x00\x00moredata"[..]),
                Ok((
                    &b"moredata"[..],
                    TupleValue::IeeeBinaryFloatingPointFloat(0.0f32)
                ))
            );
            assert_eq!(
                ieee_binary_floating_point_float(&b"\x20\x7F\xFF\xFF\xFFmoredata"[..]),
                Ok((
                    &b"moredata"[..],
                    TupleValue::IeeeBinaryFloatingPointFloat(-0.0f32)
                ))
            );
            assert_eq!(
                ieee_binary_floating_point_float(&b"\x20\xFF\x80\x00\x00moredata"[..]),
                Ok((
                    &b"moredata"[..],
                    TupleValue::IeeeBinaryFloatingPointFloat(f32::INFINITY)
                ))
            );
            assert_eq!(
                ieee_binary_floating_point_float(&b"\x20\x00\x7F\xFF\xFFmoredata"[..]),
                Ok((
                    &b"moredata"[..],
                    TupleValue::IeeeBinaryFloatingPointFloat(f32::NEG_INFINITY)
                ))
            );

            // b"\x20\xFF\xFF\xFF\xFF" and b"\x20\x00\x00\x00\x00
            // results in f32::NAN, but they cannot be compared.

            assert_eq!(
                ieee_binary_floating_point_float(&b"no_ieee_binary_floating_point_float"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_ieee_binary_floating_point_float"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                ieee_binary_floating_point_float(&b"\x20\xC0\x48\xF5"[..]),
                Err(nom::Err::Error(nom::error::Error::new(
                    &b"\xC0\x48\xF5"[..],
                    nom::error::ErrorKind::Eof
                )))
            );

            assert_eq!(
                tuple_extractor::ieee_binary_floating_point_float(
                    ieee_binary_floating_point_float(&b"\x20\xC0\x48\xF5\xC3moredata"[..])
                        .unwrap()
                        .1
                )
                .unwrap(),
                3.14f32
            );
        }

        #[test]
        fn test_ieee_binary_floating_point_double() {
            assert_eq!(
                ieee_binary_floating_point_double(
                    &b"\x21\xC0\x09\x1E\xB8\x51\xEB\x85\x1Fmoredata"[..]
                ),
                Ok((
                    &b"moredata"[..],
                    TupleValue::IeeeBinaryFloatingPointDouble(3.14f64)
                ))
            );
            assert_eq!(
                ieee_binary_floating_point_double(
                    &b"\x21\x3F\xF6\xE1\x47\xAE\x14\x7A\xE0moredata"[..]
                ),
                Ok((
                    &b"moredata"[..],
                    TupleValue::IeeeBinaryFloatingPointDouble(-3.14f64)
                ))
            );
            assert_eq!(
                ieee_binary_floating_point_double(
                    &b"\x21\x80\x00\x00\x00\x00\x00\x00\x00moredata"[..]
                ),
                Ok((
                    &b"moredata"[..],
                    TupleValue::IeeeBinaryFloatingPointDouble(0.0f64)
                ))
            );
            assert_eq!(
                ieee_binary_floating_point_double(
                    &b"\x21\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFFmoredata"[..]
                ),
                Ok((
                    &b"moredata"[..],
                    TupleValue::IeeeBinaryFloatingPointDouble(-0.0f64)
                ))
            );
            assert_eq!(
                ieee_binary_floating_point_double(
                    &b"\x21\xFF\xF0\x00\x00\x00\x00\x00\x00moredata"[..]
                ),
                Ok((
                    &b"moredata"[..],
                    TupleValue::IeeeBinaryFloatingPointDouble(f64::INFINITY)
                ))
            );
            assert_eq!(
                ieee_binary_floating_point_double(
                    &b"\x21\x00\x0F\xFF\xFF\xFF\xFF\xFF\xFFmoredata"[..]
                ),
                Ok((
                    &b"moredata"[..],
                    TupleValue::IeeeBinaryFloatingPointDouble(f64::NEG_INFINITY)
                ))
            );

            // b"\x21\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" and
            // b"\x21\x00\x00\x00\x00\x00\x00\x00\x00 results in
            // f64::NAN, but they cannot be compared.

            assert_eq!(
                ieee_binary_floating_point_double(&b"no_ieee_binary_floating_point_double"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_ieee_binary_floating_point_double"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                ieee_binary_floating_point_double(&b"\x21\xC0\x09\x1E\xB8\x51\xEB\x85"[..]),
                Err(nom::Err::Error(nom::error::Error::new(
                    &b"\xC0\x09\x1E\xB8\x51\xEB\x85"[..],
                    nom::error::ErrorKind::Eof
                )))
            );

            assert_eq!(
                tuple_extractor::ieee_binary_floating_point_double(
                    ieee_binary_floating_point_double(
                        &b"\x21\xC0\x09\x1E\xB8\x51\xEB\x85\x1Fmoredata"[..]
                    )
                    .unwrap()
                    .1
                )
                .unwrap(),
                3.14f64
            );
        }

        #[test]
        fn test_false_value() {
            assert_eq!(
                false_value(&b"\x26moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::FalseValue))
            );
            assert_eq!(
                false_value(&b"no_false_value"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_false_value"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::false_value(false_value(&b"\x26moredata"[..]).unwrap().1).unwrap(),
                false
            );
        }

        #[test]
        fn test_true_value() {
            assert_eq!(
                true_value(&b"\x27moredata"[..]),
                Ok((&b"moredata"[..], TupleValue::TrueValue))
            );
            assert_eq!(
                true_value(&b"no_true_value"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_true_value"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                tuple_extractor::true_value(true_value(&b"\x27moredata"[..]).unwrap().1).unwrap(),
                true
            );
        }

        #[test]
        fn test_rfc_1422_uuid() {
            assert_eq!(
        	     rfc_1422_uuid(
        		 &b"\x30\xFF\xFF\xFF\xFF\xBA\x5E\xBA\x11\x00\x00\x00\x00\x5C\xA1\xAB\x1Emoredata"[..]
        	     ),
        	Ok((&b"moredata"[..], TupleValue::Rfc4122Uuid(Uuid::parse_str("ffffffff-ba5e-ba11-0000-00005ca1ab1e").unwrap())))
            );
            assert_eq!(
                rfc_1422_uuid(&b"no_rfc_1422_uuid"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_rfc_1422_uuid"[..],
                    ErrorKind::Tag
                )))
            );
            assert_eq!(
                rfc_1422_uuid(
                    &b"\x30\xFF\xFF\xFF\xFF\xBA\x5E\xBA\x11\x00\x00\x00\x00\x5C\xA1\xAB"[..]
                ),
                Err(nom::Err::Error(nom::error::Error::new(
                    &b"\xFF\xFF\xFF\xFF\xBA\x5E\xBA\x11\x00\x00\x00\x00\x5C\xA1\xAB"[..],
                    nom::error::ErrorKind::Eof
                )))
            );

            assert_eq!(
        	tuple_extractor::rfc_1422_uuid(
        	    rfc_1422_uuid(
        		&b"\x30\xFF\xFF\xFF\xFF\xBA\x5E\xBA\x11\x00\x00\x00\x00\x5C\xA1\xAB\x1Emoredata"[..]).unwrap().1
        	).unwrap(),
        	Uuid::parse_str("ffffffff-ba5e-ba11-0000-00005ca1ab1e").unwrap()
            );
        }

        #[test]
        fn test_versionstamp_96_bit() {
            assert_eq!(
                versionstamp_96_bit(
                    &b"\x33\xAA\xBB\xCC\xDD\xEE\xFF\x00\x01\x02\x03\x00\x00moredata"[..]
                ),
                Ok((
                    &b"moredata"[..],
                    TupleValue::Versionstamp96Bit(Versionstamp::complete(
                        Bytes::from_static(&b"\xAA\xBB\xCC\xDD\xEE\xFF\x00\x01\x02\x03"[..]),
                        0
                    ))
                ))
            );
            assert_eq!(
                versionstamp_96_bit(
                    &b"\x33\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x02\x91moredata"[..]
                ),
                Ok((
                    &b"moredata"[..],
                    TupleValue::Versionstamp96Bit(Versionstamp::complete(
                        Bytes::from_static(&b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A"[..]),
                        657
                    ))
                ))
            );
            assert_eq!(
                versionstamp_96_bit(&b"no_versionstamp_96_bit"[..]),
                Err(nom::Err::Error(Error::new(
                    &b"no_versionstamp_96_bit"[..],
                    ErrorKind::Tag
                )))
            );

            assert_eq!(
                tuple_extractor::versionstamp_96_bit(
                    versionstamp_96_bit(
                        &b"\x33\xAA\xBB\xCC\xDD\xEE\xFF\x00\x01\x02\x03\x00\x00moredata"[..]
                    )
                    .unwrap()
                    .1
                )
                .unwrap(),
                Versionstamp::complete(
                    Bytes::from_static(&b"\xAA\xBB\xCC\xDD\xEE\xFF\x00\x01\x02\x03"[..]),
                    0
                )
            );
        }

        // `test_size_limits_pos_int` and `test_size_limits_neg_int`
        // below were written in order to determine the boundaries for
        // various integer sizes. Leaving it here, in case we need to
        // come back and debug this part of code sometime in the
        // future.

        // #[test]
        // fn test_size_limits_pos_int() {
        //     let size_limits_pos: Vec<i128> = vec![
        //         // (1 << (0 * 8)) - 1,
        //         // (1 << (1 * 8)) - 1,
        //         // (1 << (2 * 8)) - 1,
        //         // (1 << (3 * 8)) - 1,
        //         // (1 << (4 * 8)) - 1,
        //         // (1 << (5 * 8)) - 1,
        //         // (1 << (6 * 8)) - 1,
        //         // (1 << (7 * 8)) - 1,
        //         // (1 << (8 * 8)) - 1,
        //     ];
        //     println!("size_limits_pos_int: {:?}", size_limits_pos);
        // }

        // #[test]
        // fn test_size_limits_neg_int() {
        //     let size_limits_neg: Vec<i128> = vec![
        //         // ((1 << (0 * 8)) * -1) + 1,
        //         // ((1 << (1 * 8)) * -1) + 1,
        //         // ((1 << (2 * 8)) * -1) + 1,
        //         // ((1 << (3 * 8)) * -1) + 1,
        //         // ((1 << (4 * 8)) * -1) + 1,
        //         // ((1 << (5 * 8)) * -1) + 1,
        //         // ((1 << (6 * 8)) * -1) + 1,
        //         // ((1 << (7 * 8)) * -1) + 1,
        //         // ((1 << (8 * 8)) * -1) + 1,
        //     ];
        //     println!("size_limits_neg_int: {:?}", size_limits_neg);
        // }
    }
}
